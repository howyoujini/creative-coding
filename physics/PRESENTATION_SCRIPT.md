# Making Motion Feel Alive
## 발표 스크립트 (20분)

---

## 슬라이드 1: 타이틀 (1분)

> **[배경: 떠다니는 파티클 애니메이션]**

안녕하세요. 오늘 발표 주제는 **"Making Motion Feel Alive"** — 물리 시뮬레이션과 운동 제어를 통한 Procedural Art입니다.

크리에이티브 코딩을 하다 보면 결국 마주치는 질문이 있습니다:

**"어떻게 하면 움직임을 자연스럽게 만들 수 있을까?"**

오늘은 이 질문에 대한 답을 찾아가는 여정입니다.

Form에서 시작해서 Motion, Behavior, 그리고 System까지.
점 하나를 그리는 것에서 시작해서, 살아 움직이는 시스템을 만드는 방법을 알아보겠습니다.

---

## 슬라이드 2: 왜 랜덤은 지루할까? (1분 30초)

> **[데모: 왼쪽 Math.random() vs 오른쪽 Time-accumulated]**

자, 이 두 데모를 보세요.

왼쪽은 `Math.random()`으로 점의 위치를 정합니다.
매 프레임마다 완전히 새로운 위치. 결과는? 깜빡거리는 노이즈입니다.

오른쪽을 보세요. 같은 랜덤이지만, **시간에 따라 누적**됩니다.
`position += velocity` 이 한 줄의 차이입니다.

**핵심 인사이트는 이겁니다:**

랜덤은 "상태"만 만듭니다.
하지만 생명감은 **시간에 따른 변화 규칙**에서 나옵니다.

생명체가 어떻게 움직이는지 생각해보세요.
이전 상태를 기억하고, 그것을 바탕으로 다음 상태를 결정합니다.
개미도, 새도, 물고기도 전부 그렇습니다.

---

## 슬라이드 3: 규칙을 설계하는 사람 (1분 30초)

> **[데모: Linear, Circular, Noise, Spring 버튼 전환]**

여기 점 하나가 있습니다.

**[Linear 클릭]**
단순 왕복. `sin(time)`만 넣었습니다. 기계적이죠?

**[Circular 클릭]**
원 궤도. `cos`와 `sin` 조합. 안정적이지만 예측 가능합니다.

**[Noise 클릭]**
Perlin noise. 유기적이고 자연스럽습니다. 마치 길을 잃은 것처럼.

**[Spring 클릭]**
스프링 물리. 마우스를 따라가는데, 탄성이 있습니다.
목표를 향해 가다가 지나치고, 다시 돌아오고.

같은 점 하나인데, 규칙에 따라 완전히 다른 "성격"이 됩니다.

**우리는 형태를 그리는 사람이 아니라, 규칙을 설계하는 사람입니다.**

---

## 슬라이드 4: Physics Map (1분)

오늘 다룰 5가지 핵심 개념입니다.

1. **Particle** — 존재의 최소 단위. position, velocity, acceleration.
2. **Force** — 움직임의 원인. 중력, 끌어당김, 밀어냄.
3. **Integration** — 시간을 어떻게 계산할 것인가.
4. **Constraint** — 형태를 유지하는 제약조건.
5. **Flow** — 공간에 방향성 부여.

오늘 다루지 않는 것도 있습니다.
정밀한 유체 역학, 강체 물리, 지형 생성 같은 복잡한 것들은 제외했습니다.

목표는 **즉각적으로 시각적 결과가 나오는**, 창작에 바로 활용 가능한 기법들입니다.

---

## 슬라이드 5: Particle (1분 30초)

> **[데모: 벽에 튕기는 공, 속도/가속도 벡터 표시]**

Particle의 구조는 간단합니다.

```javascript
class Particle {
  position: Vector    // 현재 위치
  velocity: Vector    // 속도 (방향 + 크기)
  acceleration: Vector // 가속도
  mass: number        // 질량
}
```

매 프레임마다 이 순서로 업데이트합니다:
**v = v + a**, 그다음 **p = p + v**

가속도가 속도를 바꾸고, 속도가 위치를 바꿉니다.

데모를 보세요. 흰색 선이 속도, 노란색 선이 가속도입니다.
벽에 부딪히면 속도 방향이 반전됩니다.

중요한 건, 이 구조가 1개든 10,000개든 동일하다는 겁니다.
파티클 하나가 제대로 움직이면, 만 개도 똑같이 움직입니다.

---

## 슬라이드 6: Force (1분 30초)

> **[데모: Gravity, Attract, Noise Force 토글]**

Force는 숫자가 아니라 **벡터**입니다. 방향과 크기를 가진 의도의 표현이죠.

세 가지 대표적인 힘을 봅시다.

**[Gravity 클릭]**
중력. 항상 아래로, 일정한 크기.

**[Attract 클릭]**
마우스를 움직여보세요. 파티클들이 마우스를 향해 끌려옵니다.

**[Noise Force 클릭]**
위치 기반 의사 랜덤 방향. 새떼 같은 움직임이 나옵니다.

**[Gravity + Attract 동시 클릭]**
여러 힘이 동시에 작용하면? 결과는 **벡터의 합**입니다.
중력으로 떨어지면서도 마우스를 향해 휘어집니다.

뉴턴의 제2법칙: **F = ma**, 즉 **a = F/m**
질량이 클수록 같은 힘에 덜 반응합니다.

---

## 슬라이드 7: Integration (1분 30초)

> **[데모: Euler vs Verlet 스프링 진동 비교]**

같은 힘이라도 **적분 방법**에 따라 완전히 다른 움직임이 나옵니다.

**Euler Integration:**
```javascript
velocity += acceleration
position += velocity
```
구현이 단순하지만, 에너지가 누적되어 폭발할 수 있습니다.

**Verlet Integration:**
```javascript
velocity = position - oldPosition
position += velocity + acceleration
```
속도를 직접 저장하지 않고, "현재 - 이전"으로 암묵적 계산.

데모를 보세요. 마우스를 빠르게 움직이면 Euler 쪽은 에너지 바가 빨갛게 치솟습니다.
Verlet은 안정적으로 유지됩니다.

**실무 선택 가이드:**
- 간단한 파티클 → Euler로 충분
- 천, 로프, 체인 → Verlet 필수

---

## 슬라이드 8: Spring (1분 30초)

> **[데모: Stiffness, Damping 슬라이더 조절]**

Spring은 제가 **"마법"**이라고 부르는 기법입니다.
가장 적은 코드로 가장 자연스러운 움직임을 만듭니다.

**Hooke의 법칙:** F = -k × (position - target)
목표와의 거리에 비례하는 복원력.

두 가지 파라미터가 있습니다:

**Stiffness (강성):**
- 높으면 빠르고 즉각적
- 낮으면 느리고 부드러움

**Damping (감쇠):**
- 높으면 오래 흔들림 (탱탱볼)
- 낮으면 빠르게 정지 (젤리)

**[슬라이더 조절하면서]**
Stiffness 최대 — 딱딱한 느낌.
Damping 최소 — 계속 흔들림.

iOS의 탄성 스크롤, 마우스 커서 따라가기, 알림 팝업 — 전부 Spring입니다.

---

## 슬라이드 9: Constraint (1분 30초)

> **[데모: Constraint ON/OFF 토글]**

형태를 "그리는" 게 아니라, 물리적 제약을 통해 "유지"합니다.

**Distance Constraint:** 두 점 사이 거리 유지.

알고리즘은 간단합니다:
```javascript
diff = p2.pos - p1.pos
distance = diff.length()
correction = (restLength - distance) / distance × 0.5
p1.pos -= diff × correction
p2.pos += diff × correction
```

**[Constraint OFF 클릭]**
보세요. 형태가 무너집니다. 모든 점이 독립적으로 떨어집니다.

**[Constraint ON 클릭]**
다시 연결. 천처럼 자연스럽게 늘어집니다.

이 단순한 규칙을 3~5번 반복하면 전체가 균형점에 수렴합니다.
천, 로프, 소프트바디, 래그돌 — 전부 이 원리입니다.

---

## 슬라이드 10: 패러다임 전환 (30초)

지금까지는 **객체 중심**이었습니다.
"각 파티클이 어떻게 움직일까?"

이제 **공간 중심**으로 바꿉니다.
"이 위치에서 어느 방향으로?"

공간 자체에 방향성을 부여하면,
수천 개의 파티클이 자연스럽게 흐릅니다.

---

## 슬라이드 11: Flow Field (1분 30초)

> **[데모: Show Vectors / Particles Only 토글]**

Flow Field는 **보이지 않는 바람**입니다.

공간을 격자로 나누고, 각 셀에 방향(벡터)을 할당합니다.
파티클은 자신의 위치에서 방향을 읽고 따릅니다.

**[Show Vectors 클릭]**
화살표가 보이죠? 파티클은 이 화살표 방향으로 힘을 받습니다.

**[Particles Only 클릭]**
화살표를 숨기면 바람에 날리는 것처럼 보입니다.

핵심: 파티클은 판단하지 않습니다.
**"여기선 이 방향"**이라는 공간의 규칙을 따를 뿐.

필드 생성에는 Perlin Noise가 가장 많이 쓰입니다.
noise(x, y, time)을 쓰면 필드가 시간에 따라 변합니다.
살아있는 바람처럼!

---

## 슬라이드 12: Curl Noise (1분 30초)

> **[데모: Scale, Intensity 슬라이더 조절]**

일반 Noise에는 문제가 있습니다.
방향이 한 점으로 뭉칩니다. 파티클이 모여서 사라지죠.

**Curl Noise**는 이걸 해결합니다.
Noise의 **회전(curl) 성분**을 계산합니다.

수학적으로 말하면, **divergence-free** — 발산이 없습니다.
물이 솟아나거나 빠져나가는 곳이 없이 그냥 흐릅니다.

**[Scale 슬라이더 조절]**
Scale 크면 — 더 큰 소용돌이
Scale 작으면 — 작고 촘촘한 소용돌이

**[Intensity 슬라이더 조절]**
Intensity 크면 — 빠른 움직임
Intensity 작으면 — 부드럽고 느린 흐름

연기, 안개, 물결, 오로라 — 전부 Curl Noise입니다.

---

## 슬라이드 13: Easing (1분)

> **[데모: Linear vs Smoothstep 비교]**

물리 시뮬레이션이 항상 필요한 건 아닙니다.

시작점과 끝점이 명확하고, 정해진 시간 내에 완료해야 한다면?
**Easing 함수**가 더 적합합니다.

왼쪽: Linear — 일정한 속도
오른쪽: Smoothstep — 천천히 시작해서 천천히 끝남

**Easing vs Spring의 차이:**
- Easing: "1초 안에 완료"
- Spring: "목표에 도달할 때까지"

UI 전환, 페이드 인/아웃에는 Easing이 더 예측 가능하고 제어하기 쉽습니다.

easings.net에 가면 30가지 이상의 easing 함수를 볼 수 있습니다.

---

## 슬라이드 14: 통합 시스템 (1분 30초)

> **[데모: Flow, Spring, Gravity 슬라이더 조절]**

자, 지금까지 배운 모든 것을 하나로 통합합니다.

- **구조:** Verlet Particles + Distance Constraints
- **힘:** Gravity + Spring + Curl Noise Flow

**[슬라이더 조절하면서]**

Flow만 최대 — 바람에 날리는 깃발
Gravity만 최대 — 무거운 체인
Spring만 최대 — 중심으로 빨려드는 형태

세 가지 조합으로 완전히 다른 "성격"이 됩니다.

**핵심 통찰:** 이 데모에서 변경한 코드는 **0줄**입니다.
파라미터만 바꿨을 뿐.

**결과물이 아니라 시스템을 만들어라.**
잘 설계된 시스템은 코드 수정 없이 무한한 변주가 가능합니다.

---

## 슬라이드 15: Closing (1분)

> **[배경: 다이나믹 파티클 애니메이션]**

오늘 배운 것들은 물리학이 아닙니다.
물리학의 아이디어를 빌려온 **창작 도구**입니다.

정확할 필요 없습니다. **느낌이 맞으면 됩니다.**

핵심 메시지 네 가지:

1. 움직임의 본질은 **시간에 따른 변화 규칙**
2. 물리 시뮬레이션은 **창작 도구**로 활용
3. 정확성보다 **느낌**이 중요
4. 하나의 시스템으로 **무한한 변주**

**Form → Motion → Behavior → System**

여러분이 만들고 싶은 움직임은 어떤 성격인가요?
무겁고 느린? 가볍고 탄성 있는? 유기적이고 흐르는?

오늘 배운 도구들로 그 성격을 코드로 표현해보세요.

---

## 슬라이드 16: Resources (1분)

마지막으로, 다음 스텝을 위한 자료들입니다.

**필수 학습 자료:**
- **The Nature of Code** — Daniel Shiffman의 책. 무료로 온라인에서 볼 수 있습니다.
- **The Coding Train** — YouTube 채널. 시각적으로 정말 잘 설명합니다.

**라이브러리:**
- **p5.js** — 가장 쉬운 시작점
- **Three.js** — 3D로 확장할 때
- **Matter.js** — 물리 엔진이 필요할 때

**추천 첫 프로젝트:**
"마우스를 따라다니는 점 100개"

Particle + Force + Spring만으로 만들 수 있는
가장 간단하면서도 매력적인 인터랙션입니다.

감사합니다.

---

## 발표 타이밍 요약

| 슬라이드 | 내용 | 시간 |
|---------|------|------|
| 1 | 타이틀 | 1:00 |
| 2 | 랜덤의 한계 | 1:30 |
| 3 | 규칙 설계 | 1:30 |
| 4 | Physics Map | 1:00 |
| 5 | Particle | 1:30 |
| 6 | Force | 1:30 |
| 7 | Integration | 1:30 |
| 8 | Spring | 1:30 |
| 9 | Constraint | 1:30 |
| 10 | 패러다임 전환 | 0:30 |
| 11 | Flow Field | 1:30 |
| 12 | Curl Noise | 1:30 |
| 13 | Easing | 1:00 |
| 14 | 통합 시스템 | 1:30 |
| 15 | Closing | 1:00 |
| 16 | Resources | 1:00 |
| **합계** | | **~20:00** |

---

## 발표 팁

1. **데모를 적극 활용하세요.** 말보다 보여주는 게 효과적입니다.
2. **슬라이더를 극단적으로 움직이세요.** 차이가 명확해집니다.
3. **청중과 상호작용하세요.** "어떤 게 더 자연스러워 보이나요?"
4. **코드는 빠르게 넘기세요.** 개념만 전달하면 됩니다.
5. **"느낌"을 강조하세요.** 정확한 물리학이 아니라 창작 도구입니다.
